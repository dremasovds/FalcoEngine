#include <string>

namespace shaders
{
	static std::string terrainTreeBillboardLightVarying =
		"vec2 v_texcoord0 : TEXCOORD0 = vec2(0.0, 0.0);\n"
		"vec3 v_position  : POSITION = vec3(0.0, 0.0, 0.0);\n"
		"\n"
		"vec3 a_position  : POSITION;\n"
		"vec2 a_texcoord0 : TEXCOORD0;\n";

	static std::string terrainTreeBillboardLightVertex =
		"$input a_position, a_texcoord0\n"
		"$output v_texcoord0, v_position\n"
		"\n"
		"uniform mat4 u_modelViewProj;\n"
		"uniform mat4 u_model[32];\n"
		"\n"
		"void main()\n"
		"{\n"
		"	gl_Position = u_modelViewProj * vec4(a_position, 1.0);\n"
		"	v_texcoord0 = a_texcoord0;\n"
		"	v_position = (u_model[0] * vec4(a_position, 1.0)).xyz;\n"
		"}\n";

	static std::string terrainTreeBillboardLightFragment =
		"$input v_texcoord0, v_position\n"
		"\n"
		"uniform sampler2D u_albedoMap;\n"
		"uniform samplerCube u_envMap;\n"
		"\n"
		"uniform vec4 u_lightPosition;\n"
		"uniform vec4 u_lightColor;\n"
		"uniform vec4 u_lightIntensity;\n"
		"uniform vec4 u_lightRadius;\n"
		"uniform vec4 u_lightType;\n"
		"uniform vec4 u_lightDirection;\n"
		"uniform vec4 u_ambientColor;\n"
		"\n"
		"uniform vec4 u_camPos;\n"
		"uniform vec4 u_giParams;\n"
		"uniform vec4 u_normal;\n"
		"\n"
		"void main()\n"
		"{\n"
		"	vec4 albedo = texture2D(u_albedoMap, v_texcoord0);\n"
		"	if (albedo.a < 0.25)\n"
		"		discard;\n"
		"\n"
		"	float radius = u_lightRadius.x;\n"
		"	float innerRadius = u_lightRadius.y;\n"
		"	float outerRadius = u_lightRadius.z;\n"
		"	float intensity = u_lightIntensity.x;\n"
		"\n"
		"	vec3 L;\n"
		"	if (u_lightType.x != 2)\n"
		"		L = normalize(u_lightPosition.xyz - v_position);\n"
		"	else\n"
		"		L = normalize(-u_lightDirection.xyz);\n"
		"\n"
		"	float distance = length(u_lightPosition.xyz - v_position);\n"
		"\n"
		"	float attenuation = 0.0;\n"
		"	if (u_lightType.x == 0) // Point light\n"
		"	{\n"
		"		attenuation = smoothstep(radius, 0.0, distance) * intensity;\n"
		"	}\n"
		"	else if (u_lightType.x == 1) // Spot light\n"
		"	{\n"
		"		float spotAttenuation = 1.0;\n"
		"		float spotDot = dot(L, -u_lightDirection.xyz);\n"
		"		\n"
		"		outerRadius = clamp(58.0 - outerRadius, 0.0, 58.0);\n"
		"		innerRadius = clamp(58.0 - innerRadius, 0.0, 58.0);\n"
		"		float spot = clamp((spotDot - radians(outerRadius)) / (radians(innerRadius) - radians(outerRadius)), 0.0, 1.0);\n"
		"		attenuation = smoothstep(radius, 0.0, distance) * intensity * spot;\n"
		"	}\n"
		"	else // Directional light\n"
		"	{\n"
		"		attenuation = 1.0 * intensity;\n"
		"	}\n"
		"	\n"
		"	//GI\n"
		"	vec3 gi = vec3(1.0);\n"
		"	float amb = 1.0;\n"
		"	if (u_giParams.x == 1.0)\n"
		"	{\n"
		"		float roughness = 1.0;\n"
		"		\n"
		"		vec3 normal = normalize(u_normal.xyz);\n"
		"		\n"
		"		vec3 N = normalize(normal);\n"
		"		vec3 V = normalize(u_camPos.xyz - v_position);\n"
		"		\n"
		"		vec3 R = reflect(V, N);\n"
		"		\n"
		"		float MAX_REFLECTION_LOD = 10.0;\n"
		"		vec3 prefilteredColor = textureCubeLod(u_envMap, R, roughness * MAX_REFLECTION_LOD).rgb;\n"
		"		gi = prefilteredColor * u_giParams.y * 5.0;\n"
		"		amb = u_giParams.y;\n"
		"	}\n"
		"	\n"
		"	vec3 radiance = u_lightColor.rgb * attenuation;\n"
		"	vec3 color = (albedo.rgb * amb * u_ambientColor.rgb) + (albedo.rgb * amb * gi) * radiance;\n"
		"	color = vec3(clamp(color.r, 0.0, 1.0), clamp(color.g, 0.0, 1.0), clamp(color.b, 0.0, 1.0));\n"
		"	gl_FragColor = vec4(color, 1.0);\n"
		"}\n";
}