#include <string>

namespace shaders
{
	static std::string outlineFinalVarying =
		"vec2 v_texcoord0 : TEXCOORD0 = vec2(0.0, 0.0);\n"
		"vec3 v_position  :	TEXCOORD1 = vec3(0.0, 0.0, 0.0);\n"
		"vec3 v_cam       :	TEXCOORD2 = vec3(0.0, 0.0, 0.0);\n"
		"\n"
		"vec3 a_position : POSITION;\n"
		"vec2 a_texcoord0 : TEXCOORD0;\n"
		"\n"
		"vec2 v_rgbNW : TEXCOORD1 = vec2(0.0, 0.0);\n"
		"vec2 v_rgbNE : TEXCOORD2 = vec2(0.0, 0.0);\n"
		"vec2 v_rgbSW : TEXCOORD3 = vec2(0.0, 0.0);\n"
		"vec2 v_rgbSE : TEXCOORD4 = vec2(0.0, 0.0);\n"
		"vec2 v_rgbM  : TEXCOORD5 = vec2(0.0, 0.0);";

	static std::string outlineFinalVertex =
		"$input a_position, a_texcoord0\n"
		"$output v_texcoord0, v_position, v_cam, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM\n"
		"\n"
		"uniform mat4 u_modelViewProj;\n"
		"uniform mat4 u_invProj;\n"
		"uniform vec4 u_screenParams;\n"
		"\n"
		"void texcoords(vec2 fragCoord, vec2 resolution,\n"
		"	out vec2 v_rgbNW, out vec2 v_rgbNE,\n"
		"	out vec2 v_rgbSW, out vec2 v_rgbSE,\n"
		"	out vec2 v_rgbM)\n"
		"{\n"
		"	vec2 inverseVP = 1.0 / resolution.xy;\n"
		"	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n"
		"	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n"
		"	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n"
		"	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n"
		"	v_rgbM = vec2(fragCoord * inverseVP);\n"
		"}\n"
		"void main()\n"
		"{\n"
		"	gl_Position = u_modelViewProj * vec4(a_position, 1.0);\n"
		"	v_texcoord0 = a_texcoord0;\n"
		"	v_position = gl_Position.xyz;\n"
		"	v_cam = (u_invProj * vec4(a_position, 1.0)).xyz;\n"
		"	\n"
		"	vec2 fragCoord = v_texcoord0 * u_screenParams.xy;\n"
		"	texcoords(fragCoord, u_screenParams.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
		"}\n";

	static std::string outlineFinalFragment =
		"$input v_texcoord0, v_position, v_cam, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM\n"
		"\n"
		"uniform sampler2D u_albedoMap;\n"
		"uniform sampler2D u_depthMap;\n"
		"uniform sampler2D u_forwardColor;\n"
		"uniform sampler2D u_forwardDepth;\n"
		"uniform vec4 u_screenParams;\n"
		"uniform vec4 u_useFXAA;\n"
		"uniform vec4 u_fogEnabled;\n"
		"uniform vec4 u_fogParams;\n"
		"uniform vec4 u_fogColor;\n"
		"uniform mat4 u_camInvProj;\n"
		"float _Scale = 3.0;\n"
		"float _DepthThreshold = 6.0;\n"
		"float _DepthNormalThreshold = 0.5;\n"
		"float _DepthNormalThresholdScale = 7.0;\n"
		"float _NormalThreshold = 0.4;\n"
		"\n"
		"#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n"
		"#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n"
		"#define FXAA_SPAN_MAX     8.0\n"
		"\n"
		"vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n"
		"	vec2 v_rgbNW, vec2 v_rgbNE,\n"
		"	vec2 v_rgbSW, vec2 v_rgbSE,\n"
		"	vec2 v_rgbM)\n"
		"	{\n"
		"	vec4 color;\n"
		"	vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n"
		"	vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n"
		"	vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n"
		"	vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n"
		"	vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n"
		"	vec4 texColor = texture2D(tex, v_rgbM);\n"
		"	vec3 rgbM = texColor.xyz;\n"
		"	vec3 luma = vec3(0.299, 0.587, 0.114);\n"
		"	float lumaNW = dot(rgbNW, luma);\n"
		"	float lumaNE = dot(rgbNE, luma);\n"
		"	float lumaSW = dot(rgbSW, luma);\n"
		"	float lumaSE = dot(rgbSE, luma);\n"
		"	float lumaM = dot(rgbM, luma);\n"
		"	float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
		"	float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
		"	\n"
		"	vec2 dir;\n"
		"	dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n"
		"	dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n"
		"	\n"
		"	float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n"
		"		(0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n"
		"	\n"
		"	float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
		"	dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n"
		"		max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n"
		"			dir * rcpDirMin)) * inverseVP;\n"
		"	\n"
		"	vec3 rgbA = 0.5 * (\n"
		"		texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n"
		"		texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n"
		"	vec3 rgbB = rgbA * 0.5 + 0.25 * (\n"
		"		texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n"
		"		texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n"
		"	\n"
		"	float lumaB = dot(rgbB, luma);\n"
		"	if ((lumaB < lumaMin) || (lumaB > lumaMax))\n"
		"		color = vec4(rgbA, texColor.a);\n"
		"	else\n"
		"		color = vec4(rgbB, texColor.a);\n"
		"	return color;\n"
		"}\n"
		"vec4 blur5(sampler2D image, vec2 uv, vec2 resolution, vec2 direction)\n"
		"{\n"
		"	vec4 color = vec4(0.0);\n"
		"	vec2 off1 = vec2(1.3333333333333333) * direction;\n"
		"	color += texture2D(image, uv) * 0.29411764705882354;\n"
		"	color += texture2D(image, uv + (off1 / resolution)) * 0.35294117647058826;\n"
		"	color += texture2D(image, uv - (off1 / resolution)) * 0.35294117647058826;\n"
		"	return color;\n"
		"}\n"
		"\n"
		"float ComputeFog(float z, float fog_start, float fog_end, float fog_density, int fog_type)\n"
		"{\n"
		"	float fog = 0.0;\n"
		"	if (fog_type == 0)\n"
		"	{\n"
		"		fog = ((fog_end - z) / (fog_end - fog_start)) * (1.0 - fog_density);\n"
		"	}\n"
		"	else if (fog_type == 1)\n"
		"	{\n"
		"		fog = exp2(-fog_density * z);\n"
		"	}\n"
		"	else\n"
		"	{\n"
		"		fog = fog_density * z;\n"
		"		fog = exp2(-fog * fog);\n"
		"	}\n"
		"\n"
		"	return 1.0 - clamp(fog, 0.0f, 1.0);\n"
		"}\n"
		"\n"
		"void main()\n"
		"{\n"
		"	float halfScaleFloor = floor(_Scale * 0.5);\n"
		"	float halfScaleCeil = ceil(_Scale * 0.5);\n"
		"\n"
		"	float texelSize = 1.0 / 1024.0;\n"
		"	vec2 bottomLeftUV = v_texcoord0 - vec2(texelSize, texelSize) * halfScaleFloor;\n"
		"	vec2 topRightUV = v_texcoord0 + vec2(texelSize, texelSize) * halfScaleCeil;\n"
		"	vec2 bottomRightUV = v_texcoord0 + vec2(texelSize * halfScaleCeil, -texelSize * halfScaleFloor);\n"
		"	vec2 topLeftUV = v_texcoord0 + vec2(-texelSize * halfScaleFloor, texelSize * halfScaleCeil);\n"
		"\n"
		"	float depth0 = texture2D(u_forwardDepth, bottomLeftUV).r;\n"
		"	float depth1 = texture2D(u_forwardDepth, topRightUV).r;\n"
		"	float depth2 = texture2D(u_forwardDepth, bottomRightUV).r;\n"
		"	float depth3 = texture2D(u_forwardDepth, topLeftUV).r;\n"
		"\n"
		"	vec3 normal0 = texture2D(u_forwardColor, bottomLeftUV).rgb;\n"
		"	vec3 normal1 = texture2D(u_forwardColor, topRightUV).rgb;\n"
		"	vec3 normal2 = texture2D(u_forwardColor, bottomRightUV).rgb;\n"
		"	vec3 normal3 = texture2D(u_forwardColor, topLeftUV).rgb;\n"
		"\n"
		"	vec3 viewNormal = normal0 * 2.0 - 1.0;\n"
		"	vec3 viewSpaceDir = v_cam;\n"
		"	float NdotV = 1 - dot(viewNormal, -viewSpaceDir);\n"
		"	float normalThreshold01 = clamp((NdotV - _DepthNormalThreshold) / (1 - _DepthNormalThreshold), 0.0, 1.0);\n"
		"	float normalThreshold = normalThreshold01 * _DepthNormalThresholdScale + 1;\n"
		"\n"
		"	float depthFiniteDifference0 = depth1 - depth0;\n"
		"	float depthFiniteDifference1 = depth3 - depth2;\n"
		"	float outline = sqrt(pow(depthFiniteDifference0, 2) + pow(depthFiniteDifference1, 2)) * 100.0;\n"
		"	float depthThreshold = _DepthThreshold * depth0 * normalThreshold;\n"
		"	outline = outline > depthThreshold ? 1 : 0;\n"
		"\n"
		"	vec3 normalFiniteDifference0 = normal1 - normal0;\n"
		"	vec3 normalFiniteDifference1 = normal3 - normal2;\n"
		"	float edgeNormal = sqrt(dot(normalFiniteDifference0, normalFiniteDifference0) + dot(normalFiniteDifference1, normalFiniteDifference1));\n"
		"	edgeNormal = edgeNormal > _NormalThreshold ? 1 : 0;\n"
		"\n"
		"	float edge = max(outline, edgeNormal);\n"
		"\n"
		"	vec2 fragCoord = v_texcoord0 * u_screenParams.xy;\n"
		"	vec4 color = vec4(0.0);\n"
		"	if (u_useFXAA.x == 1.0)\n"
		"		color = fxaa(u_albedoMap, fragCoord, u_screenParams.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n"
		"	else\n"
		"		color = texture2D(u_albedoMap, v_texcoord0);\n"
		"	vec4 col = texture2D(u_forwardColor, v_texcoord0);\n"
		"	vec3 highlight = vec3(1.0, 0.62, 0.07) * col.a * 0.1;\n"
		"	vec3 line = (vec3(edge) * vec3(1.0, 0.62, 0.07)) * 0.7;\n"
		"	line = highlight.r > 0 ? vec3(0, 0, 0) : line;\n"
		"\n"
		"	if (u_fogEnabled.x == 1.0)\n"
		"	{\n"
		"		float _depth = texture2D(u_depthMap, v_texcoord0).r;\n"
		"		vec4 clip = vec4(v_texcoord0 * 2.0 - 1.0, _depth * 2.0 - 1.0, 1.0);\n"
		"		vec4 view = u_camInvProj * clip;\n"
		"		float dist = length(view.xyz / view.w);\n"
		"		float fog_start = u_fogParams.x;\n"
		"		float fog_end = u_fogParams.y;\n"
		"		float fog = ComputeFog(dist, fog_start, fog_end, u_fogParams.z, int(u_fogParams.w));\n"
		"\n"
		"		if (u_fogEnabled.y != 1.0)\n"
		"		{\n"
		"			if (_depth == 1.0)\n"
		"				fog = 0.0;\n"
		"		}\n"
		"\n"
		"		color = vec4(mix(color, u_fogColor, fog * u_fogColor.a).rgb, color.a);\n"
		"	}\n"
		"\n"
		"	float alpha = texture2D(u_albedoMap, v_texcoord0).a;\n"
		"	gl_FragColor = vec4(color.rgb + line + highlight, alpha);\n"
		"}\n";
}